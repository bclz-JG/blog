---
title: 用sql语句进行排名
date: 2020-3-20
tags: [sql, DB, MySQL]
categories: Database
---

### 正文

---
编写一个 SQL 查询来实现分数排名。如果两个分数相同，则两个分数排名（Rank）相同。请注意，平分后的下一个名次应该是下一个连续的整数值。换句话说，名次之间不应该有“间隔”。
````
+----+-------+
| Id | Score |
+----+-------+
| 1  | 3.50  |
| 2  | 3.65  |
| 3  | 4.00  |
| 4  | 3.85  |
| 5  | 4.00  |
| 6  | 3.65  |
+----+-------+
````
例如，根据上述给定的 Scores 表，你的查询应该返回（按分数从高到低排列）：
````
+-------+------+
| Score | Rank |
+-------+------+
| 4.00  | 1    |
| 4.00  | 1    |
| 3.85  | 2    |
| 3.65  | 3    |
| 3.65  | 3    |
| 3.50  | 4    |
+-------+------+
````
### 分析

---
目前我只想到一种不太高效的方法，最后的结果包含两个部分，第一部分是按照降序排列的的分数，第二部分是对每个分数进行相应的排名
第一部分很容易写，很常规：
````
select a.Score as Score
from Scores a
order by a.Score DESC
````
比较难的是第二部分，不太好理解。假如给出一个分数x，如何决定他的排名呢？

我这里先取出所有**大于等于x**的所有分数集合，设为C，则将C去重复后得到的就是x的排名。比如我考了99分，在C中的最高分就是99分（不管有多少个），那么去重之后C中就只有一个99，个数为1，因此我的排名也是1.
我们先提取C集合：
````
select s.Score from Scores s where s.Score >= x;
````
从结果来看，第二部分的Rank是根据第一部分的分数来的，所以这里的x就是上面的a.Score，将两部分合在一起写为：
````
select a.Score Score,
(select count(distinct s.Score) from Scores s where s.Score >= a.Score) Rank
from Scores a
order by a.Score DESC
````

### 总结

---
这样的方法虽然可以实现想要的功能，但是每一个值都要进行一个C集合查找，效率其实是很低的。